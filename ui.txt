#include <lvgl.h>
#include <TFT_eSPI.h>
#include <ui.h>
#include <Adafruit_ADS1X15.h>
Adafruit_ADS1115 ads;


static const uint16_t screenWidth  = 480;
static const uint16_t screenHeight = 320;
enum { SCREENBUFFER_SIZE_PIXELS = screenWidth * screenHeight / 10 };

static lv_color_t buf [SCREENBUFFER_SIZE_PIXELS];
TFT_eSPI tft = TFT_eSPI( screenWidth, screenHeight );

int fahrstufe;
int druckVA;
int druckHA;
int wunschdruckVA;
int wunschdruckHA;
int druckvaok = 0;
int druckhaok = 0;

void my_disp_flush (lv_display_t *disp, const lv_area_t *area, uint8_t *pixelmap)
{
    uint32_t w = ( area->x2 - area->x1 + 1 );
    uint32_t h = ( area->y2 - area->y1 + 1 );
    if (LV_COLOR_16_SWAP) {
        size_t len = lv_area_get_size( area );
        lv_draw_sw_rgb565_swap( pixelmap, len );
    }
    tft.startWrite();
    tft.setAddrWindow( area->x1, area->y1, w, h );
    tft.pushColors( (uint16_t*) pixelmap, w * h, true );
    tft.endWrite();
    lv_disp_flush_ready( disp );
}

void my_touchpad_read(lv_indev_t* indev_driver, lv_indev_data_t* data) 
{
    uint16_t touchX = 0, touchY = 0;

    bool touched = tft.getTouch(&touchX, &touchY, 600);

    if (!touched) {
        data->state = LV_INDEV_STATE_REL;
    } else {
        data->state = LV_INDEV_STATE_PR;
        data->point.x = touchX;
        data->point.y = touchY;
    }
}
static uint32_t my_tick_get_cb (void) { return millis(); }

void setup ()
{
    pinMode(2, OUTPUT);
pinMode(4, OUTPUT);
    pinMode(5, OUTPUT);
pinMode(18, OUTPUT);
digitalWrite(2, LOW);
digitalWrite(4, LOW);
digitalWrite(5, LOW);
digitalWrite(18, LOW);

      uint16_t calData[5] = { 287, 3587, 315, 3322, 1 };
  tft.setTouch(calData);
    Serial.begin( 115200 );
  tft.init();
  tft.setRotation(3);
    lv_init();
    static lv_disp_t* disp;
    disp = lv_display_create( screenWidth, screenHeight );
    lv_display_set_buffers( disp, buf, NULL, SCREENBUFFER_SIZE_PIXELS * sizeof(lv_color_t), LV_DISPLAY_RENDER_MODE_PARTIAL );
    lv_display_set_flush_cb( disp, my_disp_flush );
    static lv_indev_t* indev;
    indev = lv_indev_create();
    lv_indev_set_type( indev, LV_INDEV_TYPE_POINTER );
    lv_indev_set_read_cb( indev, my_touchpad_read );
    lv_tick_set_cb( my_tick_get_cb );
    ui_init();

      if (!ads.begin())
  {
    Serial.println("Failed to initialize ADS.");
    while (1);
  }
}

void loop ()
{
int16_t adc0, adc1;
adc0 = ads.readADC_SingleEnded(0);
adc1 = ads.readADC_SingleEnded(1);
float druckVAreal = druckVA / 10.0;
float druckHAreal = druckHA / 10.0;
float wunschdruckVAreal = wunschdruckVA / 10.0;
float wunschdruckHAreal = wunschdruckHA / 10.0;
druckVA = map(adc0, 0, 17500, 0, 150);
druckHA = map(adc1, 0, 17500, 0, 150);
if (druckvaok == 0) {
if (wunschdruckVA > druckVA) {
      digitalWrite(2, HIGH);
    } else {
digitalWrite(2, LOW);
    }
if (wunschdruckVA < druckVA) {
      digitalWrite(4, HIGH);
    } else {
digitalWrite(4, LOW);
    }
}
if (wunschdruckVA == druckVA) {
      druckvaok = 1;}
      
if (druckhaok == 0) {
if (wunschdruckHA > druckHA) {
      digitalWrite(18, HIGH);
    } else {
digitalWrite(18, LOW);
    }
if (wunschdruckHA < druckHA) {
      digitalWrite(5, HIGH);
    } else {
digitalWrite(5, LOW);
    }
}
if (wunschdruckHA == druckHA) {
      druckhaok = 1;}
lv_label_set_text_fmt(ui_LABELaktuellerdruckVA, "%.1f", druckVAreal ); 
lv_arc_set_value(ui_ARCva, druckVA);
lv_label_set_text_fmt(ui_LABELaktuellerdruckHA, "%.1f", druckHAreal );
lv_arc_set_value(ui_ARCha, druckHA);
lv_label_set_text_fmt(ui_LABELwunschdruckVA, "%.1f", wunschdruckVAreal);
lv_label_set_text_fmt(ui_LABELfahrstufe, "%d", fahrstufe);
lv_label_set_text_fmt(ui_LABELwunschdruckHA, "%.1f", wunschdruckHAreal);
lv_arc_set_value(ui_ARCvawunsch, wunschdruckVA);
lv_arc_set_value(ui_ARChawunsch, wunschdruckHA);
   
    lv_timer_handler();
    delay(5);
}